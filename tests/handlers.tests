Identity handler (1)
{ handle(42) {case Return(x) -> x} }
stdout : 42 : Int
flags : --enable-handlers -e

Identity handler (2)
handle(42) {case Return(x) -> x}
stdout : 42 : Int
flags : --enable-handlers -e

Listify handler (1)
{ handle(42) {case Return(x) -> [x]} }
stdout : [42] : [Int]
flags : --enable-handlers -e

Listify handler (2)
handle(42) {case Return(x) -> [x]}
stdout : [42] : [Int]
flags : --enable-handlers -e

Listify handler (3)
{ handle([42, 41, 40, 39]) {case Return(x) -> [x]} }
stdout : [[42, 41, 40, 39]] : [[Int]]
flags : --enable-handlers -e

Listify handler (4)
handle([42, 41, 40, 39]) {case Return(x) -> [x]}
stdout : [[42, 41, 40, 39]] : [[Int]]
flags : --enable-handlers -e

Top level operation invocation
{ do Foo }
stderr : @.
exit : 1
flags : --enable-handlers -e

Return invocation (1)
fun() { do Return }
stderr : @.
exit : 1
flags : --enable-handlers -e

Return invocation (2)
{ fun() { do Return } }
stderr : @.
exit : 1
flags : --enable-handlers -e

Operation invocation sugar (1)
{ fun() { do Foo } }
stdout : fun : () {Foo:a|_}-> a
flags : --enable-handlers -e

Operation invocation sugar (2)
{ fun() { do Foo() } }
stdout : fun : () {Foo:a|_}-> a
flags : --enable-handlers -e

Operation invocation sugar (3)
{ fun() { do Foo(()) } }
stdout : fun : () {Foo:(()) {}-> a|_}-> a
flags : --enable-handlers -e

Operation invocation sugar (4)
fun() { do Foo }
stdout : fun : () {Foo:a|_}-> a
flags : --enable-handlers -e

Operation invocation sugar (5)
fun() { do Foo() }
stdout : fun : () {Foo:a|_}-> a
flags : --enable-handlers -e

Operation invocation sugar (6)
fun() { do Foo(()) }
stdout : fun : () {Foo:(()) {}-> a|_}-> a
flags : --enable-handlers -e

Exception handling (1)
{ handle({do Fail; 42}) {case Fail(_) -> Nothing : Maybe(Int) case Return(x) -> Just(x) : Maybe(Int)} }
stdout : Nothing : Maybe (Int)
flags : --enable-handlers -e

Exception handling (2)
{ handle(42) {case Fail(_) -> Nothing : Maybe(Int) case Return(x) -> Just(x) : Maybe(Int)} }
stdout : Just(42) : Maybe (Int)
flags : --enable-handlers -e

Exception handling (3)
{ handle({var _ = do Fail : Zero; 42}) {case Fail(k) -> k(42) : Either(String,Int) case Return(x) -> Right(x) : Either(String, Int)} }
stderr : @.
exit : 1
flags : --enable-handlers -e

Exception handling (4)
handle({do Fail; 42}) {case Fail(_) -> Nothing : Maybe(Int) case Return(x) -> Just(x) : Maybe(Int)}
stdout : Nothing : Maybe (Int)
flags : --enable-handlers -e

Exception handling (5)
handle(42) {case Fail(_) -> Nothing : Maybe(Int) case Return(x) -> Just(x) : Maybe(Int)}
stdout : Just(42) : Maybe (Int)
flags : --enable-handlers -e

Exception handling (6)
handle({var _ = do Fail : Zero; 42}) {case Fail(k) -> k(42) : Either(String,Int) case Return(x) -> Right(x) : Either(String, Int)}
stderr : @.
exit : 1
flags : --enable-handlers -e

Binary choice handling (1)
{ handle({ var x = if (do Choose) 40 else 20; var y = if (do Choose) 2 else -20; x + y }) {case Choose(k) -> k(true) ++ k(false) case Return(x) -> [x]} }
stdout : [42, 20, 22, 0] : [Int]
flags : --enable-handlers -e

Binary choice handling (2)
handle({ var x = if (do Choose) 40 else 20; var y = if (do Choose) 2 else -20; x + y }) {case Choose(k) -> k(true) ++ k(false) case Return(x) -> [x]}
stdout : [42, 20, 22, 0] : [Int]
flags : --enable-handlers -e

Deep continuation escape (1)
{ fromJust(handle({ do Escape; print("Back in action"); do Escape}) { case Escape(k) -> Just(k) case Return(_) -> Nothing })(()) }
stdout : @.
exit : 0
flags : --enable-handlers -e

Deep continuation escape (2)
fromJust(handle({ do Escape; print("Back in action"); do Escape}) { case Escape(k) -> Just(k) case Return(_) -> Nothing })(())
stdout : @.
exit : 0
flags : --enable-handlers -e

Type-and-effect signature for deep handler (1)
sig allChoices : (Comp({Choose:Bool|e},a)) {Choose{_}|e}~> [a] fun allChoices(m) {handle(m()) {case Return(x) -> [x] case Choose(k) -> k(true) ++ k(false) }}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for deep handler (2)
sig allChoices : (Comp({Choose:Bool|e},a)) -> Comp({Choose{_}|e},[a]) fun allChoices(m)() {handle(m()) {case Return(x) -> [x] case Choose(k) -> k(true) ++ k(false)}}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for deep handler (3)
sig allChoices : (Comp({Choose:Bool|e},a)) -> Comp({Choose- |e},[a]) fun allChoices(m)() {handle(m()) {case Return(x) -> [x] case Choose(k) -> k(true) ++ k(false)}}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for deep handler (4)
sig allChoices : (Comp({Choose:Bool|e},a)) -> Comp({Choose{_}|e},[a]) handler allChoices {case Return(x) -> [x] case Choose(k) -> k(true) ++ k(false)}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for deep handler (5)
sig allChoices : (Comp({Choose:Bool|e},a)) -> Comp({Choose- |e},[a]) handler allChoices {case Return(x) -> [x] case Choose(k) -> k(true) ++ k(false)}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for shallow handler (1)
sig allChoices : (Comp({Choose:Bool|e},a)) {Choose{_}|e}~> [a] fun allChoices(m) {shallowhandle(m()) {case Return(x) -> [x] case Choose(k) -> allChoices(fun() {k(true)}) ++ allChoices(fun(){k(false)}) }}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for shallow handler (2)
sig allChoices : (Comp({Choose:Bool|e},a)) -> Comp({Choose{_}|e},[a]) fun allChoices(m)() {shallowhandle(m()) {case Return(x) -> [x] case Choose(k) -> allChoices(fun(){k(true)})() ++ allChoices(fun(){k(false)})()}}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for shallow handler (3)
sig allChoices : (Comp({Choose:Bool|e},a)) -> Comp({Choose- |e},[a]) fun allChoices(m)() {shallowhandle(m()) {case Return(x) -> [x] case Choose(k) -> allChoices(fun(){k(true)})() ++ allChoices(fun(){k(false)})()}}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for shallow handler (4)
sig allChoices : (Comp({Choose:Bool|e},a)) -> Comp({Choose{_}|e},[a]) shallowhandler allChoices {case Return(x) -> [x] case Choose(k) -> allChoices(fun(){k(true)})() ++ allChoices(fun(){k(false)})()}
stdout : () : ()
flags : --enable-handlers -e

Type-and-effect signature for shallow handler (5)
sig allChoices : (Comp({Choose:Bool|e},a)) -> Comp({Choose- |e},[a]) shallowhandler allChoices {case Return(x) -> [x] case Choose(k) -> allChoices(fun(){k(true)})() ++ allChoices(fun(){k(false)})()}
stdout : () : ()
flags : --enable-handlers -e

Soundness
{fun mapk(m) { handle(m()) {case Map(p,k) -> map(k,p) case Return(x) -> [x]} } }
stderr : @.
exit : 1
flags : --enable-handlers -e

Deep state handling (1)
{fun state(m) { handle(m()) { case Get(k) -> fun(s) { k(s)(s) } case Put(p,k) -> fun(s) { k(())(p) } case Return(x) -> fun(s) { x } } } fun runState(s0, c) { var f = state(c); f(s0) } runState(2, fun() { var s = do Get; do Put(s + 1); var s = do Get; do Put(s + s); do Get }) }
stdout : 6 : Int
flags : --enable-handlers -e

Deep state handling (2)
{handler state(s) { case Get(k) -> k(s)(s) case Put(p,k) -> k(())(p) case Return(x) -> x } fun runState(s0, c) { state(s0)(c)() } runState(2, fun() { var s = do Get; do Put(s + 1); var s = do Get; do Put(s + s); do Get }) }
stdout : 6 : Int
flags : --enable-handlers -e

Shallow state handling (1)
{fun state(m)(s) { shallowhandle(m()) { case Get(k) -> state(fun(){k(s)})(s) case Put(p,k) -> state(fun(){k(())})(p) case Return(x) -> x}} fun runState(s0, c) { var f = state(c); f(s0) } runState(2, fun() { var s = do Get; do Put(s + 1); var s = do Get; do Put(s + s); do Get }) }
stdout : 6 : Int
flags : --enable-handlers -e

Shallow state handling (2)
{ shallowhandler simpleState(s) { case Get(k) -> simpleState(s)(fun() { k(s) })() case Put(s,k) -> simpleState(s)(fun() { k(()) })() case Return(x) -> x } fun count() { var n = do Get; if (n == 0) {n} else {do Put(n-1); count() }} simpleState(10)(count)() }
stdout : 0 : Int
flags : --enable-handlers -e

Shadowing handler parameter (1)
{ handler state(s) { case Get(k) -> k(s)(s) case Put(s,k) -> k(())(s) case Return(x) -> x } fun comp() { var s = do Get; do Put(s + 1); var s = do Get; do Put(s + s); do Get } state(0)(comp)()  }
stdout : 2 : Int
flags : --enable-handlers -e

Shadowing handler parameter (2)
{ handler state(s) { case Get(k) -> k(s)(s) case Put(p as s,k) -> k(())(s) case Return(x) -> x } fun comp() { var s = do Get; do Put(s + 1); var s = do Get; do Put(s + s); do Get } state(0)(comp)()  }
stdout : 2 : Int
flags : --enable-handlers -e

Shadowing handler parameter (3)
{ handler state(s) { case Get(k) -> k(s)(s) case Put(s as p,k) -> k(())(s) case Return(x) -> x } fun comp() { var s = do Get; do Put(s + 1); var s = do Get; do Put(s + s); do Get } state(0)(comp)()  }
stdout : 2 : Int
flags : --enable-handlers -e

Operation parameter pattern-matching (1)
handler h1 { case Op1(_) -> 1 case Op2(_,k) -> 2 case Op3(_,_) -> 3 case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Operation parameter pattern-matching (2)
handler h1 { case Op1(p as q,k) -> k(q) case Op2(s,t as w,k) -> k(t) case Op3(a,b,c as d,_) -> d case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Operation parameter pattern-matching (3)
handler h1 { case Op1(1,k) -> k(1) case Op2(s,2,k) -> k(s) case Op3(a,b,3,_) -> 3 case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Operation parameter pattern-matching (4)
handler h1 { case Op1(1.0,k) -> k(1.0) case Op2(s,2.0,k) -> k(s) case Op3(a,b,3.0,_) -> 3.0 case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Operation parameter pattern-matching (5)
handler h1 { case Op1(Alice,k) -> k(1) case Op2(s,Bob,k) -> k(s) case Op3(a,b,Jenny,_) -> a case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Operation parameter pattern-matching (6)
handler h1 { case Op1((_,y),k) -> k(y) case Op2((x,y,z),k) -> k(z) case Op3(_,(a,b,c),_) -> a case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Pattern-matching on continuation parameter (1)
handler h1 { case Op(_) -> 0 case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Pattern-matching on continuation parameter (2)
handler h1 { case Op(k as f) -> f(1) case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Pattern-matching on continuation parameter (3)
handler h1 { case Op(2) -> f(1) case Return(x) -> x }
stderr : @.
exit : 1
flags : --enable-handlers -e

Return parameter pattern-matching (1)
handler h1 { case Op1(k) -> 1 case Return(_) -> 0 }
stdout : () : ()
flags : --enable-handlers -e

Return parameter pattern-matching (2)
handler h1 { case Op1(k) -> 1 case Return(x as y) -> y }
stdout : () : ()
flags : --enable-handlers -e

Return parameter pattern-matching (3)
handler h1 { case Op1(k) -> 1 case Return(10) -> 10 }
stdout : () : ()
flags : --enable-handlers -e

Return parameter pattern-matching (4)
handler h1 { case Op1(k) -> 1 case Return(100.0) -> 0 }
stdout : () : ()
flags : --enable-handlers -e

Return parameter pattern-matching (5)
handler h1 { case Op1(k) -> 1 case Return(Alice) -> 0 }
stdout : () : ()
flags : --enable-handlers -e

Return parameter pattern-matching (6)
handler h1 { case Op1(k) -> 1 case Return((x,y)) -> 0 }
stdout : () : ()
flags : --enable-handlers -e

Deep Handler composition
handler h1 { case Op1(k) -> k(1) case Return(x) -> x } handler h2 { case Op2(k) -> k(2) case Return(x) -> x } handler h3 { case Op3(k) -> k(3) case Return(x) -> x } h1(h2(h3(fun() { do Op1 + do Op2 + do Op3 })))()
stdout : 6 : Int
flags : --enable-handlers -e

Type annotation on deep continuation parameter
handler h1 { case Op(k : ((Int) {Op{_}|_}~> Int)) -> k(1) case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Type annotation on shallow continuation parameter
shallowhandler h1 { case Op(k : ((Int) {Op:Int|_}~> Int)) -> h1(fun() { k(1) })() case Return(x) -> x }
stdout : () : ()
flags : --enable-handlers -e

Shallow addition with a single recursive handler
{ shallowhandler h1 { case One(k) -> h1(fun() { k(1) })() case Return(x) -> x - 1} h1(fun() { do One + do One })() }
stdout : 1 : Int
flags : --enable-handlers -e

Shallow addition with two mutual recursive handlers
{ shallowhandler h1 { case One(k) -> h1(fun() { k(1) })() case Return(x) -> x} shallowhandler h2 { case One(k) -> h1(fun() { k(2) })() case Return(x) -> x} h2(fun() { do One + do One })() }
stdout : 3 : Int
flags : --enable-handlers -e

Shallow handler composition
{ shallowhandler h1 { case Op1(k) -> h1(fun() { k(1) })() case Return(x) -> x } shallowhandler h2 { case Op2(k) -> h2(fun() { k(2) })() case Return(x) -> x } h1(h2(fun() { do Op1 + do Op2 }))() }
stdout : 3 : Int
flags : --enable-handlers -e

Type ascription, parameterised handlers (1)
{ handler(_ : Int)(_ : Float)(_ : String) { case Op(p,k) -> k(p)(42)(3.14)("Foo") case Return(x) -> x } }
stdout : fun : (Int) -> (Float) -> (String) -> (() {Op:(d) {}-> d|e}~> f) -> () {Op{_}|e}~> f
flags : --enable-handlers -e

Type ascription, parameterised handlers (2)
{ handler(_ : Float,_ : String,_ : Int) { case Op(p,k) -> k(p)(3.14,"Bar",99) case Return(x) -> x } }
stdout : fun : (Float, String, Int) -> (() {Op:(b) {}-> b|c}~> d) -> () {Op{_}|c}~> d
flags : --enable-handlers -e

Instantiate.ArityMismatch #132 (RESOLVED)
sig f : (() {Foo:Int|a}~> b) {Foo{_}|a}~> b fun f(m) { error("N/A") } fun g(m) { var x = f(m); x }
stdout : () : ()
flags : --enable-handlers -e

Operation polymorphism
sig catch : (() {Fail:forall a.a |e}~> b) {Fail{_} |e}~> Maybe(b) fun catch(m) { handle(m()) { case Fail(k) -> Nothing case Return(x) -> Just(x) } } catch(fun() { 42 })
stdout : Just(42) : Maybe (Int)
flags : --enable-handlers -e

Generalise (1)
gen0(handler { case Foo(k) -> 42 case Return(x) -> x }(fun(){42}))
stdout : fun : Comp ({ |a },Int)
flags : --enable-handlers -e

Generalise (2)
gen0(handler { case Foo(k : ((()) {Foo- |_}~> Int)) -> 42 case Return(x) -> x }(fun(){42}))
stdout : fun : Comp ({ |a },Int)
flags : --enable-handlers -e

Unification error
{ fun h1(m,h) { handle(m()) { case Foo(k) -> h(fun() { k(()) },h1) case Return(x) -> x } } fun h2(m,h) { handle(m()) { case Foo(k) -> h(fun() { k(()) },h2) case Return(x) -> x } } h1(fun(){42},h2) }
flags : --enable-handlers -e
ignore : Known unification bug (*** Error: "Assert_failure unify.ml:136:14")

Examples
./examples/handlers/tests.links
stdout : () : ()
flags : --enable-handlers -m --path=examples/handlers