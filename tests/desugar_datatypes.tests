Type variables are correctly scoped
typename A = forall a::Eff. forall a::Type. () ~a~> ();
exit : 1
stderr : @.*Mismatch in kind for type variable `a'.*

Subkind declaration mismatches are reported
() : (( | a :: Any)) { | a :: Eff }~> ()
exit : 1
stderr : @.*Mismatch in kind for type variable `a'\..*

Kind declaration mismatches are reported
() : forall a::Row. (a) ~a~> ()
exit : 1
stderr : @.*Mismatch in kind for type variable `a'\..*

Kind usage mismatches are reported
() : (a) ~a~> ()
exit : 1
stderr : @.*Mismatch in kind for type variable `a'\..*

Quantifiers within nested definitions are allowed [1]
./tests/desugar_datatypes/nestedQuantifiers1.links
filemode : true
stdout : () : ()

Quantifiers within nested definitions are allowed [2]
./tests/desugar_datatypes/nestedQuantifiers2.links
filemode : true
stdout : () : ()

Qualified type variables default to a kind of Type
typename Arrow (a) = () -a-> ();
exit : 1
stderr : @.*Mismatch in kind for type variable `a'.*

Free type variables are detected
typename A = a;
exit : 1
stderr : @.*Unbound type variable `a'.*

Implicit type variables are detected
typename A = () -> ();
exit : 1
stderr : @.*Unbound anonymous type variable.*

Free type variables are detected (in nested definitions)
./tests/desugar_datatypes/nestedTypename.links
filemode : true
exit : 1
stderr : @.*Unbound type variable `a'.*

Rows can be promoted to types
./tests/desugar_datatypes/rowPromote.links
filemode : true
stdout : () : ()
ignore : Not sure if a good idea yet.
