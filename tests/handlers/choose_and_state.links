fun incr(x) {var y = xunl{do Get}; do Put(x+y)}

fun choice() {
  var x = if (xunl{do Choose()}) { incr(1); do Get }
          else { incr(1); do Get };
  var y = if (xunl{do Choose()}) { incr(1); do Get }
          else { incr(1); do Get };
  x + y
}

fun enumerate(m)() {
  handle(xunl{m()}) {
    # NOTE: Unlike `new_choose.links`, this `xunl` is necessary
    # if you want to combine these two handlers
    case Choose(k) -> xunl{k(true) ++ k(false)}
    case Return(x) -> [x]
  }
}

fun evalState(st)(m)() {
  (xunl{handle(xunl{m()}) {
    case Return(x) -> fun(_)  { x }
    case Get(k)    -> fun(st) { xunl{k(st)(st)} }
    case Put(p,k)  -> fun(_)  { xunl{k(())(p)}  }
  }})(st)
}

evalState(0)(enumerate(choice))() ++ enumerate(evalState(0)(choice))()