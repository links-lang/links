Sugar off [1]
sig f : (() {E|e}~> ()) -> () {E{_}|e}~> () fun f(g) { fun() { handle(g()) { case E(res) -> res(()) }}} f
stdout : fun : (() {E:() -> ()|a}~> ()) -> () {E{_}|a}~> ()
args : --enable-handlers --set=effect_sugar=false

Sugar off [2], implicit not unifying, no propagation
sig f : (() {E|_}~> ()) -> () { |_}~> () fun f(g) { fun() { handle(g()) { case E(res) -> res(()) }}} f
stderr : @.
exit : 1
args : --enable-handlers --set=effect_sugar=false

Policy: none [1], signature with explicit shared effect
sig f : (() {E|e}~> ()) -> () {E{_}|e}~> () fun f(g) { fun() { handle(g()) { case E(res) -> res(()) }}} f
stdout : fun : (() {E:() {}-> ()|_}~> ()) -_-> () {E{_}|_}~> ()
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: none [2], signature with implicit shared effect
sig f : (() {E|_}~> ()) -> () {E{_}|_}~> () fun f(g) { fun() { handle(g()) { case E(res) -> res(()) }}} f
stdout : fun : (() {E:() {}-> ()|_}~> ()) -_-> () {E{_}|_}~> ()
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: none [3], type alias
typename T(a, e::Eff) = (a) -e-> a; sig f : T(a) fun f(x) { x } f
stdout : fun : T (_,{ |_})
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: none [4], type alias
typename T(a) = (a) -> a; sig f : T(a) fun f(x) { x } f
stdout : fun : T (_,{ |_})
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: none [4], type alias implicit
typename T(a, e::Eff) = (a) -e-> a; sig f : T(a, { |e}) fun f(x) { x } f
stdout : fun : T (_)
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=alias_omit

Policy: none [5], no ccf
sig map : ((a) ~> b) -> ([a]) ~> [b] fun map(f)(xs) { switch(xs) { case [] -> [] case (x::xs) -> f(x) :: map(f)(xs) }} map
stdout : fun : ((a) ~> c) -_-> ([a]) ~> [c]
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: none [6], no ccf
sig map : ((a) ~> b) -> ([a]) -> () ~> [b] fun map(f)(xs)() { switch(xs) { case [] -> [] case (x::xs) -> f(x) :: map(f)(xs)() }} map
stdout : fun : ((a) ~> c) -_-> ([a]) -_-> () ~> [c]
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: none [7], no arrows_show_the_one_effect
sig map : ((a) ~e~> b, [a]) ~e~> [b] fun map(f, lst) { switch(lst) { case [] -> [] case (x::xs) -> f(x) :: map(f, xs) }} map
stdout : fun : ((a) ~> c, [a]) ~> [c]
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: none [8], no arrows_show_the_one_effect
sig map : ((a) ~e~> b) -> ([a]) ~e~> [b] fun map(f)(lst) { switch(lst) { case [] -> [] case (x::xs) -> f(x) :: map(f)(xs) }} map
stdout : fun : ((a) ~> c) -_-> ([a]) ~> [c]
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: none [9], dot when not open_default not allowed
sig ask : () {Ask:a|.}-> a fun ask() { do Ask } ask
stderr : @.
exit : 1
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=none

Policy: presence_omit [1]: signature with implicit shared effect, handler
sig f : (() {E|_}~> ()) -> () {E{_}|_}~> () fun f(g) { fun() { handle(g()) { case E(res) -> res(()) }}} f
stdout : fun : (() {E:() {}-> ()|_}~> ()) -_-> () ~> ()
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=presence_omit

Policy: presence_omit [2]: signature with implicit shared effect, handler, propagation
sig f : (() {E|_}~> ()) -> () { |_}~> () fun f(g) { fun() { handle(g()) { case E(res) -> res(()) }}} f
stdout : fun : (() {E:() {}-> ()|_}~> ()) -_-> () ~> ()
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=presence_omit

Policy: presence_omit [3]: multiple shared effect rows
sig f : (() {E:() {}-> ()|e}~> (), () {F:() {}-> ()|f}~> ()) -> (() {E{_}|e}~> (), () {F{_}|f}~> ()) fun f(p,q) { var p = fun() { handle(p()) { case Return(v) -> v case E(res) -> res(()) }}; var q = fun() { handle(q()) { case Return(v) -> v case F(res) -> res(()) }}; (p,q) } f
stdout : fun : (() {E:() {}-> ()|a}~> (), () {F:() {}-> ()|b}~> ()) -> (() ~a~> (), () ~b~> ())
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=presence_omit

Policy: alias_omit [1], printer only
typename T(a, e::Eff) = (a) -e-> a; sig f : T(a, { |e}) fun f(x) { x } f
stdout : fun : T (_)
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=alias_omit

Policy: alias_omit [2], desugaring + printer
typename T(a, e::Eff) = (a) -e-> a; sig f : T(a) fun f(x) { x } f
stdout : fun : T (_)
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=alias_omit

Policy: alias_omit [3], desugaring + printer
typename T(a) = (a) -> a; sig f : T(a) fun f(x) { x } f
stdout : fun : T (_)
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=alias_omit

Policy: presence_omit, alias_omit [1], handler
sig f : (Comp ((), {E|_})) -> Comp ((), {E{_}|_}) fun f(x)() { handle(x()) { case Return() -> () case E(res) -> () }} f
stdout : fun : (Comp ((),{E:() {}-> ()|_})) -_-> Comp (())
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=presence_omit,alias_omit

Policy: presence_omit, alias_omit, ccf [1], handler
sig f : (Comp ((), {E|_})) -> Comp ((), {E{_}|_}) fun f(x)() { handle(x()) { case Return() -> () case E(res) -> () }} f
stdout : fun : (Comp ((),{E:() {}-> ()|_})) -> Comp (())
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=presence_omit,alias_omit,ccf

Policy: pres, alias, ccf, contract [1], handler
sig f : (Comp ((), {E|_})) -> Comp ((), {E{_}|_}) fun f(x)() { handle(x()) { case Return() -> () case E(res) -> () }} f
stdout : fun : (Comp ((),{E:()|_})) -> Comp (())
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=pres,alias,ccf,contract

Policy: contract_operation_arrows [1]
sig f : (a) {E:(a) {}-> b}-> b fun f(x) { do E(x) } f
stdout : fun : (a) {E:(a) -> b}-> b
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=contract

Policy: contract_operation_arrows [2]
sig f : () {E:() {}-> a}-> a fun f() { do E } f
stdout : fun : () {E:a}-> a
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=contract

Policy: contract_operation_arrows [3]
sig f : () {E:() {}-> ()}-> () fun f() { do E } f
stdout : fun : () {E:()}-> ()
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=contract

Policy: contract_operation_arrows [4]
sig f : (a) {E:(a) {}-> ()}-> () fun f(x) { do E(x) } f
stdout : fun : (a) {E:(a) -> ()}-> ()
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=contract

Policy: ccf [1]
sig map : ((a) ~> b) -> ([a]) ~> [b] fun map(f)(xs) { switch(xs) { case [] -> [] case (x::xs) -> f(x) :: map(f)(xs) }} map
stdout : fun : ((a) ~> c) -> ([a]) ~> [c]
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=ccf

Policy: ccf [2]
sig map : ((a) ~> b) -> ([a]) -> () ~> [b] fun map(f)(xs)() { switch(xs) { case [] -> [] case (x::xs) -> f(x) :: map(f)(xs)() }} map
stdout : fun : ((a) ~> c) -> ([a]) -> () ~> [c]
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=ccf

Policy: arrows_show_the_one_effect [1]
sig map : ((a) ~e~> b, [a]) ~e~> [b] fun map(f, lst) { switch(lst) { case [] -> [] case (x::xs) -> f(x) :: map(f, xs) }} map
stdout : fun : ((a) ~b~> c, [a]) ~b~> [c]
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=arrows_show_the_one_effect

Policy: arrows_show_the_one_effect [2]
sig map : ((a) ~e~> b) -> ([a]) ~e~> [b] fun map(f)(lst) { switch(lst) { case [] -> [] case (x::xs) -> f(x) :: map(f)(xs) }} map
stdout : fun : ((a) ~b~> c) -> ([a]) ~b~> [c]
args : --enable-handlers --set=effect_sugar=true --set=effect_sugar_policy=arrows_show_the_one_effect

Policy: open_default [1], open
sig ask : () {Ask:a}-> a fun ask() { do Ask } ask
stdout : fun : () {Ask:() { |.}-> a}-> a
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=open_default

Policy: open_default [2], closed
sig ask : () {Ask:a|.}-> a fun ask() { do Ask } ask
stdout : fun : () {Ask:() { |.}-> a|.}-> a
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=open_default

Policy: contract_operation_arrows, open_default [1], open
sig ask : () {Ask:a}-> a fun ask() { do Ask } ask
stdout : fun : () {Ask:a}-> a
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=open_default,contract

Policy: contract_operation_arrows, open_default [2], closed
sig ask : () {Ask:a|.}-> a fun ask() { do Ask } ask
stdout : fun : () {Ask:a|.}-> a
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=open_default,contract

Policy: contract_operation_arrows, open_default [3], open
sig ask : (a) {Ask:(a) { |.}-> b}-> b fun ask(x) { do Ask(x) } ask
stdout : fun : (a) {Ask:(a) -> b}-> b
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=open_default,contract

Policy: contract_operation_arrows, open_default [4], closed
sig ask : (a) {Ask:(a) { |.}-> b|.}-> b fun ask(x) { do Ask(x) } ask
stdout : fun : (a) {Ask:(a) -> b|.}-> b
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=open_default,contract

Policy: contract_operation_arrows, open_default [5], open, include desugaring
sig ask : (a) {Ask:(a) -> b}-> b fun ask(x) { do Ask(x) } ask
stdout : fun : (a) {Ask:(a) -> b}-> b
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=open_default,contract

Policy: contract_operation_arrows, open_default [6], closed, include desugaring
sig ask : (a) {Ask:(a) -> b|.}-> b fun ask(x) { do Ask(x) } ask
stdout : fun : (a) {Ask:(a) -> b|.}-> b
args : --enable-handlers --set=prelude=tests/empty_prelude.links --set=effect_sugar=true --set=effect_sugar_policy=open_default,contract