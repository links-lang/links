fun incr(x) {var y = do Get; do Put(x+y)}

# this example shows that we can use linear operations
# in an environment surrounded by unlimited operations
fun choice() {
  var x = if (lindo Choose()) { incr(1); do Get }
          else { incr(1); do Get };
  var y = if (lindo Choose()) { incr(1); do Get }
          else { incr(1); do Get };
  x + y
}

fun positive(m)() {
  handle(m()) {
    case x -> x
    case <Choose =@ k> -> xlin; k(true)
  }
}

fun evalState(st)(m)() {
  (handle(m()) {
    case x -> fun(_)  { x }
    case <Get => k>    -> fun(st) { k(st)(st) }
    case <Put(p) => k> -> fun(_)  { k(())(p)  }
  })(st)
}

# This is not well-typed. Probably this can be an disadvantage
# of using row polymorphism. The basic reason is that the linear
# k is used in the handler positive, thus all effects must be linear,
# which excludes Get and Put.
# evalState(0)(positive(choice))()

positive(evalState(0)(choice))()