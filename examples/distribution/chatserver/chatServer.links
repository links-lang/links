open ChatSessions
open ChatClient

#  typename LoopProc =
#    Process({ hear:[|BroadcastMessage : Message | BroadcastChangeTopic: Topic
#                    | GetServerState : Process ({ hear:(Topic, [Nickname]) })
#                    | NewClient : (Nickname, ServerToClientChannel)  |]});

## clientHandler loop: Reads incoming requests from the client, dispatches
## each command to the serverLoop which will broadcast to other session clients.
# Alas, we can't make this an inner function at the moment since we need a type
# annotation, and type annotations are broken for inner functions at the moment
#sig clientHandlerLoop :
#  forall a::Any. (ReceiveCommand, LoopProc) ~> a
fun clientHandlerLoop(nick, clientToServerChan, loopPid) {

  offer(clientToServerChan) {
    case ChatMessage(clientToServerChan) ->
      var (msg, clientToServerChan) = receive(clientToServerChan);
      loopPid ! BroadcastMessage(nick, msg);
      clientHandlerLoop(nick, clientToServerChan, loopPid)
    case ChangeTopic(clientToServerChan) ->
      var (newTopic, clientToServerChan) = receive(clientToServerChan);
      loopPid ! BroadcastChangeTopic(newTopic);
      clientHandlerLoop(nick, clientToServerChan, loopPid)
  }
}


# Process that is spawned to handle
#sig clientHandler : forall a::Any.(ChatServer, ~ServerToClientChannel, LoopProc) ~> a
fun clientHandler(nick, chatServerRecvEnd, serverToClientRecvEnd, loopPid) {

  # Get the current topic and nicks
  loopPid ! GetServerState(self());
  var (topic, nicks) = receive { case st -> st };

  # Send topic, nicks, and outgoing channel
  #var wrappedNicks = map(fun(s) { Nickname(s) }, nicks);
  var chatServerRecvEnd =
    send((topic, nicks, serverToClientRecvEnd), chatServerRecvEnd);

  clientHandlerLoop(nick, chatServerRecvEnd, loopPid)
}

fun clientSendHandler(s) {
  receive {
    case DeliverMessage(nick, msg) ->
      var s = select IncomingChatMessage s;
      var s = send((nick, msg), s);
      clientSendHandler(s)
    case DeliverNewUser(nick) ->
      var s = select NewUser s;
      var s = send(nick, s);
      clientSendHandler(s)
    case DeliverNewTopic(topic) ->
      var s = select NewTopic s;
      var s = send(topic, s);
      clientSendHandler(s)
    case DeliverUserLeft(nick) ->
      var s = select UserLeft s;
      var s = send(nick, s);
      clientSendHandler(s)
  }
}
fun broadcastMessage(msg, pids) {
  switch(pids) {
    case [] -> ()
    case pid :: pids -> pid ! msg; broadcastMessage(msg, pids)
  }
}


fun serverLoop(topic, nicks, pids) {
  receive {
    case BroadcastMessage(nick, msg) ->
      broadcastMessage(DeliverMessage(nick, msg), pids);
      serverLoop(topic, nicks, pids)
    case BroadcastChangeTopic(newTopic) ->
      broadcastMessage(DeliverNewTopic(newTopic), pids);
      serverLoop(newTopic, nicks, pids)
    case NewClient(nick, pid) ->
      broadcastMessage(DeliverNewUser(nick), pids);
      serverLoop(topic, nick :: nicks, pid :: pids)
    case GetServerState(pid) ->
      pid ! (topic, nicks);
      serverLoop(topic, nicks, pids)
  }
}

fun acceptor(ap, loopPid) server {
  # Accept a new client
  var clientToServerRecvEnd = accept(ap);

  # Get the name and incoming message channel of the new client
  # FIXME: Blocking operation in acceptor loop....
  var (name, clientToServerRecvEnd) = receive(clientToServerRecvEnd);

  debug("before fork");

  # Fork off the client handler,
  var serverToClientSendEnd = linFork(
    linfun (serverToClientRecvEnd) {
      clientHandler(name, clientToServerRecvEnd, serverToClientRecvEnd, loopPid)
  });

  debug("after fork");

  # For off client send handler
  var clientSendHandlerPid = spawn { clientSendHandler(serverToClientSendEnd) };

  # Register with the main loop, and recurse
  loopPid ! NewClient(name, clientSendHandlerPid);
  acceptor(ap, loopPid)
}

fun main() {
  var (clientAP:AP(ChatServer)) = new();
  var loopPid = spawn { serverLoop(Topic("Hello, ABCD!"), [], []) };
  var _ = spawn { acceptor(clientAP, loopPid) };
  addRoute("/", fun (_, _) { ChatClient.mainPage(clientAP) } );
  addStaticRoute("/css", "css", [("css", "text/css")]);
  serveWebsockets("/ws/");
  servePages()
}

main()
