open ChatSessions
open ChatClient

#  typename LoopProc =
#    Process({ hear:[|BroadcastMessage : Message | BroadcastChangeTopic: Topic
#                    | GetServerState : Process ({ hear:(Topic, [Nickname]) })
#                    | NewClient : (Nickname, ServerToClientChannel)  |]});

## clientHandler loop: Reads incoming requests from the client, dispatches
## each command to the serverLoop which will broadcast to other session clients.
# Alas, we can't make this an inner function at the moment since we need a type
# annotation, and type annotations are broken for inner functions at the moment
#sig clientHandlerLoop :
#  forall a::Any. (ReceiveCommand, LoopProc) ~> a
fun clientHandlerLoop(nick, clientToServerChan, loopPid) {

  offer(clientToServerChan) {
    case ChatMessage(clientToServerChan) ->
      var (msg, clientToServerChan) = receive(clientToServerChan);
      loopPid ! BroadcastMessage(nick, msg);
      clientHandlerLoop(nick, clientToServerChan, loopPid)
    case ChangeTopic(clientToServerChan) ->
      var (newTopic, clientToServerChan) = receive(clientToServerChan);
      loopPid ! BroadcastChangeTopic(newTopic);
      clientHandlerLoop(nick, clientToServerChan, loopPid)
  }
}


# Process that is spawned to handle
#sig clientHandler : forall a::Any.(ChatServer, ~ServerToClientChannel, LoopProc) ~> a
fun clientHandler(nick, chatServerRecvEnd, serverToClientRecvEnd, loopPid) {

  # Get the current topic and nicks
  var (topic, nicks) =
    spawnWait {
      loopPid ! GetServerState(self());
      receive { case st -> st }
    };

  # Send topic, nicks, and outgoing channel
  #var wrappedNicks = map(fun(s) { Nickname(s) }, nicks);
  var chatServerRecvEnd =
    send((topic, nicks, serverToClientRecvEnd), chatServerRecvEnd);

  clientHandlerLoop(nick, chatServerRecvEnd, loopPid)
}

fun clientSendHandler(s) {
  receive {
    case DeliverMessage(nick, msg) ->
      var s = select IncomingChatMessage s;
      var s = send((nick, msg), s);
      clientSendHandler(s)
    case DeliverNewUser(nick) ->
      var s = select NewUser s;
      var s = send(nick, s);
      clientSendHandler(s)
    case DeliverNewTopic(topic) ->
      var s = select NewTopic s;
      var s = send(topic, s);
      clientSendHandler(s)
    case DeliverUserLeft(nick) ->
      var s = select UserLeft s;
      var s = send(nick, s);
      clientSendHandler(s)
  }
}

#sig broadcastChatMessage: (Nickname, Message, [])
#  ~%e~> SessionList(ServerToClientChannel)
#fun broadcastChatMessage(senderName, msg, chans) {
#  fun f(chan) {
#   var chan = select IncomingChatMessage chan;
#    send((senderName, msg), chan)
#  }
#  mapCh(f, chans)
#}

#sig broadcastChangeTopic : (Topic, [ServerToClientChannel]) ~%e~> [ServerToClientChannel]
#fun broadcastChangeTopic(topic, participants) {
#  fun f(chan) {
#    var chan = select NewTopic chan;
#    send(topic, chan)
#  }
#  mapCh(f, participants)
#}





# lol
#typename Msg = (ChatSessions.Message);
#typename Top = (ChatSessions.Topic);
#typename Nick = (ChatSessions.Nickname);
#typename SrvToClientChan = (ChatSessions.ServerToClientChannel);
#sig serverLoop :
#  forall a::Any.(Topic, [Nickname], SessionList(ServerToClientChannel))
#    { hear:[|BroadcastMessage : Msg | BroadcastChangeTopic: Top
#                  | GetServerState : Process ({ hear:(Top, [Nick]) })
#                  | NewClient : (Nick, SrvToClientChan) |]}~>
#    a

fun broadcastMessage(msg, pids) {
  switch(pids) {
    case [] -> ()
    case pid :: pids -> pid ! msg; broadcastMessage(msg, pids)
  }
}


fun serverLoop(topic, nicks, pids) {
  receive {
    case BroadcastMessage(nick, msg) ->
      #var chans = broadcastChatMessage(nick, msg, chans);
      broadcastMessage(DeliverMessage(nick, msg), pids);
      serverLoop(topic, nicks, pids)
    case BroadcastChangeTopic(newTopic) ->
      broadcastMessage(DeliverNewTopic(topic), pids);
 #     var chans = broadcastChangeTopic(newTopic, chans);
      serverLoop(newTopic, nicks, pids)
    case NewClient(nick, pid) ->
      serverLoop(topic, nick :: nicks, pid :: pids)
    case GetServerState(pid) ->
    #  pid ! (topic, nicks);
      serverLoop(topic, nicks, pids)
  }
}

fun acceptor(ap, loopPid) {
  # Accept a new client
  var clientToServerRecvEnd = accept(ap);

  # Get the name and incoming message channel of the new client
  # FIXME: Blocking operation in acceptor loop....
  var (name, clientToServerRecvEnd) = receive(clientToServerRecvEnd);

  # Fork off the client handler,
  var serverToClientSendEnd = linFork(
    linfun (serverToClientRecvEnd) {
      clientHandler(name, clientToServerRecvEnd, serverToClientRecvEnd, loopPid)
  });

  # For off client send handler
  var clientSendHandlerPid = spawn { clientSendHandler(serverToClientSendEnd) };

  # Register with the main loop, and recurse
  loopPid ! NewClient(name, clientSendHandlerPid);
  acceptor(ap, loopPid)
}

fun main() {
  var (clientAP:AP(ChatServer)) = new();
  var loopPid = spawn { serverLoop(Topic("Hello, ABCD!"), [], []) };
  var _ = spawn { acceptor(clientAP, loopPid) };
  addRoute("/", fun (_, _) { ChatClient.mainPage(clientAP) } );
  serveWebsockets("/ws/");
  servePages()
}

main()
