# Deep and shallow implementations of pipes along with their
# interencodings.
#
# The direct implementations are adapted from Kammar et al. (2013)
# whilst the encoded implementations are adapted from HillerstrÃ¶m and
# Lindley (2018).

typename Comp(e::Eff,a) = () ~e~> a;

# Basic combinators.
sig await : () { Await: s |e}-> s
fun await() { do Await }

sig yield : (s) { Yield: (s) -> () |e}-> ()
fun yield(s) { do Yield(s) }

sig forever : (Comp({ |e}, a)) ~e~> b
fun forever(f) { ignore(f()); forever(f) }

sig blackhole : Comp({Await:s |e}, a)
fun blackhole() { forever(await) }

sig take1 : (Int) -> Comp({Await:s, Yield:(s) -> () |e}, ())
fun take1(n)() {
  fun take0(n) {
    if (n <= 0) ()
    else {
      var x = await();
      yield(x);
      take0(n-1)
   }
 }
 take0(n)
}

sig produceFrom : (Int) -> Comp({ Yield: (Int) -> () |e}, a)
fun produceFrom(n)() {
  fun produceFrom0(n) {
     yield(n);
     produceFrom0(n+1)
  }
  produceFrom0(n)
}

fun skip1(n)() {
  fun skip0(n) {
    var x = await();
    if (n <= 0) yield(x)
    else skip0(n-1)
  }
  skip0(n)
}

fun printer(toString)() {
  var x = await();
  print(toString(x))
}


module Deep {
  mutual {
    typename Producer(e::Eff, s, a) = () ~e~> (Consumer({ |e}, s, a)) ~e~> a;
    typename Consumer(e::Eff, s, a) = (s) ~e~> (Producer({ |e}, s, a)) ~e~> a;
  }

  module Direct {
    typename Pipe(e::Eff, s, a) = forall b::Presence, c::Presence.
               (Comp({ Await: s, Yield{c} |e}, a)) { Await{b}, Yield{c} |e}~>
                      (Producer({ Await{b}, Yield{c} |e}, s, a)) { Await{b}, Yield{c} |e}~> a;

    sig pipe : Pipe({ |e}, s, a)
    fun pipe(cons) {
      handle(cons()) {
        case Return(x) -> fun(_) { x }
        case Await(resume) ->
          fun(prod : Producer({ Await{b}, Yield{c} |e}, s, a)) {
            prod()(resume)
          }
      }
    }

    typename Copipe(e::Eff, s, a) = forall b::Presence, c::Presence.
              (Comp({ Await{b}, Yield: (s) -> () |e}, a)) { Await{b}, Yield{c} |e}~>
                     (Consumer({ Await{b}, Yield{c} |e}, s, a)) { Await{b}, Yield{c} |e}~> a;

    sig copipe : Copipe({ |e}, s, a)
    fun copipe(prod) {
      handle(prod()) {
        case Return(x) -> fun(_) { x }
        case Yield(s, resume) ->
          fun(cons : Consumer({ Await{b}, Yield{c} |e}, s, a)) {
            cons(s)(fun() { resume(()) })
          }
      }
    }
  }
}


op producer >+> consumer {
  fun() { Deep.Direct.pipe(consumer)(fun() { Deep.Direct.copipe(producer) }) }
}

sig expoPipe : (Int) -> Comp({ Await: Int, Yield: (Int) -> () |e}, a)
fun expoPipe(n)() {
  fun expoPipe0(n) {
    if (n == 0) {
       forever(fun() {
         var x = await();
         yield(x+1)
       })
    } else {
        Deep.Direct.pipe(fun() {expoPipe0(n-1)})(fun() { Deep.Direct.copipe(fun() {expoPipe0(n-1)}) })
    }
  }
  expoPipe0(n)
}

fun nested(start, depth, end) {
  var pipeline = produceFrom(start) >+> expoPipe(depth) >+> take1(end) >+> printer(intToString);
  pipeline()
}

fun simple() {
  var pipeline = produceFrom(0) >+> skip1(1000) >+> printer(intToString);
  pipeline()
}

nested(0, 8, 10)
