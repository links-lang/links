#
# Cooperative concurrency
#

# type of a concurrent computation
typename Co(e::Row) = Comp ({Fork : (Co({ |e})) {}-> (),
                             Yield : () | e},
                            ());

## cooperative concurrency interface
sig fork : (Co({ |e})) {Fork:(Co({ |e})) {}-> ()|_}~> ()
fun fork(p) {do Fork(p)}

sig yield : Comp({Yield:()|_}, ())
fun yield() {do Yield}

# example abstract concurrent computation
sig test : Co({ |e})
fun test() {
  println("M1 ");
  fork(fun () {println("A1 "); yield(); println ("A2 ")});
  println("M2 ");
  yield();
  fork(fun () {println("B1 "); yield(); println ("B2 ")});
  yield();
  println("M3 ");
  yield();
  println("\n");
}

## queue interface
sig enqueue : (a) {Enqueue:(a) {}-> b|e}-> b
fun enqueue(x) {do Enqueue(x)}

sig dequeue : () {Dequeue:a|e}-> a
fun dequeue() {do Dequeue}

## process queues

# process queue computations
typename Proc(e::Row) =
  Comp ({Enqueue:(Proc({ |e})) {}-> (),
         Dequeue:Maybe(Proc({ |e}))
        |e}, ());

# return true if the process queue is empty
sig dequeueAndRun : Comp ({Enqueue:(Proc({ |e})) {}-> (),
                           Dequeue:Maybe(Proc({ |e}))
                      |e}, Bool)
fun dequeueAndRun() {
  switch (dequeue()) {
    case (Just(p)) -> p(); false
    case Nothing   ->      true
  }
}

sig runNext : Proc({ |e})
fun runNext() {
  ignore(dequeueAndRun())
}

sig runAll : Proc({ |e})
fun runAll() {
  if (dequeueAndRun()) {()} else {runAll()}
}

## implementations of cooperative concurrency

# defer forked processes
sig scheduleBreadthFirst :
  (Co({Enqueue:(Proc({Fork{p}, Yield{q} | e})) {}-> (),
       Dequeue:Maybe(Proc({Fork{p}, Yield{q} |e}))
      |e})) ->
   Proc ({Fork{p}, Yield{q} | e})
handler scheduleBreadthFirst {
  case Yield(k)   -> enqueue(fun() {k (())}); runNext()
  case Fork(p, k) -> enqueue(scheduleBreadthFirst(p)); k(())
  case Return(()) -> runAll()
}

# eagerly run forked processes
sig scheduleDepthFirst :
  (Co({Enqueue:(Proc({Fork{p}, Yield{q} | e})) {}-> (),
       Dequeue:Maybe(Proc({Fork{p}, Yield{q} |e}))
      |e})) ->
   Proc ({Fork{p}, Yield{q} | e})
handler scheduleDepthFirst {
  case Yield(k)   -> enqueue(fun() {k (())});
                     runNext();
  case Fork(p, k) -> enqueue(fun() {k (())});
                     scheduleDepthFirst(p)()
  case Return(()) -> runAll()
}

# randomly choose when to run forked processes
sig scheduleRandom :
  (Co({Enqueue:(Proc({Fork{p}, Yield{q} | e})) {}-> (),
       Dequeue:Maybe(Proc({Fork{p}, Yield{q} |e}))
      |e})) ->
   Proc ({Fork{p}, Yield{q} | e})
handler scheduleRandom {
  case Yield(k)   -> enqueue(fun() {k (())}); runNext();
  case Fork(p, k) -> if (random() < 0.5) {
                       enqueue(scheduleRandom(p)); k(())
                     } else {
                       enqueue(fun() {k (())});
                       scheduleRandom(p)()
                     }
  case Return(()) -> runAll()
}


## queue implementation using a zipper
sig zipQueue :
  (Comp ({Enqueue:(s) {}-> (), Dequeue:Maybe(s)|e}, a)) ->
   Comp ({Enqueue{_},          Dequeue{_}      |e}, a)
fun zipQueue(m) {
  (handler (front, back) {
     case Enqueue(x, k) -> k(())(front, x :: back)
     case Dequeue(k)    ->
       switch ((front, back)) {
         case ([], [])   -> k(Nothing)([], [])
         case ([], back) -> var (x::front) = reverse(back);
                            k(Just(x))(front, [])
         case (x::front, back) -> k(Just(x))(front, back)
       }
     case Return(x) -> x
   })([], [])(m)
}


# zipQueue(scheduleRandom(test))()
